use quiche::multicast;
use quiche::multicast::authentication::McAuthType;
use quiche::multicast::McAnnounceData;
use quiche::multicast::McPathType;
use quiche::multicast::MulticastChannelSource;
use quiche::multicast::MulticastClientTp;
use quiche::multicast::MulticastConnection;
use ring::rand::*;
use std::net;

pub mod mc_server {
    use super::*;

    #[inline]
    pub fn get_multicast_channel(
        mc_keylog_file: &str,
        authentication: multicast::authentication::McAuthType, ttl_data: u64,
        rng: &SystemRandom, soft_mc: bool,
    ) -> (
        Option<mio::net::UdpSocket>,
        Option<MulticastChannelSource>,
        Option<McAnnounceData>, // Data.
        Option<McAnnounceData>, // Authentication.
    ) {
        let mc_addr = "224.3.0.225:8889".parse().unwrap();
        let mc_addr_bytes = [224, 3, 0, 225];
        let mc_port = 8889;
        let source_addr = "127.0.0.1:4434".parse().unwrap();
        let socket = mio::net::UdpSocket::bind(source_addr).unwrap();

        let mc_client_tp = MulticastClientTp::default();
        let mut server_config = get_test_mc_config(true, None, true);
        let mut client_config =
            get_test_mc_config(false, Some(&mc_client_tp), true);

        // Generate a random source connection ID for the connection.
        let mut channel_id = [0; 16];
        rng.fill(&mut channel_id[..]).unwrap();

        let channel_id = quiche::ConnectionId::from_ref(&channel_id);
        let channel_id_vec = channel_id.as_ref().to_vec();

        let mc_path_info = multicast::McPathInfo {
            local: source_addr,
            peer: source_addr,
            cid: channel_id,
        };

        // Authentication path information if symmetric authentication is used.
        let mut channel_id_auth = [0; 16];
        let mc_auth_info = if authentication == McAuthType::SymSign {
            rng.fill(&mut channel_id_auth).unwrap();
            let channel_id = quiche::ConnectionId::from_ref(&channel_id_auth);

            let dummy_ip = std::net::Ipv4Addr::new(224, 3, 0, 225);
            let to2 = std::net::SocketAddr::V4(std::net::SocketAddrV4::new(
                dummy_ip,
                mc_port + 1,
            ));

            Some(multicast::McPathInfo {
                local: to2,
                peer: to2,
                cid: channel_id,
            })
        } else {
            None
        };

        let mut mc_channel = MulticastChannelSource::new_with_tls(
            mc_path_info,
            &mut server_config,
            &mut client_config,
            mc_addr,
            mc_keylog_file,
            authentication,
            mc_auth_info,
        )
        .unwrap();

        let mc_announce_data = McAnnounceData {
            // channel_id: mc_channel.mc_path_conn_id.0.as_ref().to_vec(),
            channel_id: channel_id_vec,
            path_type: McPathType::Data,
            auth_type: authentication,
            is_ipv6: soft_mc,
            source_ip: [127, 0, 0, 1],
            group_ip: mc_addr_bytes,
            udp_port: mc_port,
            public_key: mc_channel
                .channel
                .get_multicast_attributes()
                .unwrap()
                .get_mc_pub_key()
                .map(|i| i.to_vec()),
            ttl_data,
            is_processed: false,
        };

        println!("MC KEY: {:?}", mc_announce_data.public_key.as_ref());

        mc_channel
            .channel
            .mc_set_mc_announce_data(&mc_announce_data)
            .unwrap();

        // MC_ANNOUNCE data of the authentication path.
        let mc_announce_auth = if authentication == McAuthType::SymSign {
            let data = McAnnounceData {
                channel_id: channel_id_auth.to_vec(),
                path_type: McPathType::Authentication,
                auth_type: McAuthType::None,
                is_ipv6: soft_mc,
                source_ip: [127, 0, 0, 1],
                group_ip: mc_addr_bytes,
                udp_port: mc_port + 1,
                public_key: None,
                ttl_data,
                is_processed: false,
            };

            mc_channel.channel.mc_set_mc_announce_data(&data).unwrap();

            Some(data)
        } else {
            None
        };

        (
            Some(socket),
            Some(mc_channel),
            Some(mc_announce_data),
            mc_announce_auth,
        )
    }

    /// Generate a stateless retry token.
    ///
    /// The token includes the static string `"quiche"` followed by the IP
    /// address of the client and by the original destination connection ID
    /// generated by the client.
    ///
    /// Note that this function is only an example and doesn't do any
    /// cryptographic authenticate of the token. *It should not be used in
    /// production system*.
    pub fn mint_token(hdr: &quiche::Header, src: &net::SocketAddr) -> Vec<u8> {
        let mut token = Vec::new();

        token.extend_from_slice(b"quiche");

        let addr = match src.ip() {
            std::net::IpAddr::V4(a) => a.octets().to_vec(),
            std::net::IpAddr::V6(a) => a.octets().to_vec(),
        };

        token.extend_from_slice(&addr);
        token.extend_from_slice(&hdr.dcid);

        token
    }

    /// Validates a stateless retry token.
    ///
    /// This checks that the ticket includes the `"quiche"` static string, and
    /// that the client IP address matches the address stored in the ticket.
    ///
    /// Note that this function is only an example and doesn't do any
    /// cryptographic authenticate of the token. *It should not be used in
    /// production system*.
    pub fn validate_token<'a>(
        src: &net::SocketAddr, token: &'a [u8],
    ) -> Option<quiche::ConnectionId<'a>> {
        if token.len() < 6 {
            return None;
        }

        if &token[..6] != b"quiche" {
            return None;
        }

        let token = &token[6..];

        let addr = match src.ip() {
            std::net::IpAddr::V4(a) => a.octets().to_vec(),
            std::net::IpAddr::V6(a) => a.octets().to_vec(),
        };

        if token.len() < addr.len() || &token[..addr.len()] != addr.as_slice() {
            return None;
        }

        Some(quiche::ConnectionId::from_ref(&token[addr.len()..]))
    }

    #[inline]
    pub fn get_test_mc_config(
        mc_server: bool, mc_client: Option<&MulticastClientTp>, use_fec: bool,
    ) -> quiche::Config {
        let mut config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();
        config
            .load_cert_chain_from_pem_file("src/bin/cert.crt")
            .unwrap();
        config
            .load_priv_key_from_pem_file("src/bin/cert.key")
            .unwrap();
        config
            .set_application_protos(&[b"proto1", b"proto2"])
            .unwrap();
        // config.set_max_idle_timeout(0);
        config.set_max_recv_udp_payload_size(1350);
        config.set_max_send_udp_payload_size(1350);
        config.set_initial_max_data(10_000_000);
        config.set_initial_max_stream_data_bidi_local(1_000_000);
        config.set_initial_max_stream_data_bidi_remote(1_000_000);
        config.set_initial_max_stream_data_uni(1_000_000);
        config.set_initial_max_streams_bidi(1_000_000);
        config.set_initial_max_streams_uni(1_000_000);
        config.set_active_connection_id_limit(5);
        config.verify_peer(false);
        config.set_multipath(true);
        config.set_enable_server_multicast(mc_server);
        config.set_enable_client_multicast(mc_client);
        config.send_fec(use_fec);
        config.receive_fec(use_fec);
        config.set_fec_scheduler_algorithm(
            quiche::FECSchedulerAlgorithm::RetransmissionFec,
        );
        config.set_cc_algorithm(quiche::CongestionControlAlgorithm::DISABLED);
        config.set_fec_symbol_size(1280 - 64); // MC-TODO: make dynamic with auth.
        config
    }
}

pub mod mc_client {
    use std::collections::HashMap;
    use std::net::SocketAddr;

    use mio::net::UdpSocket;
    use quiche::multicast::authentication::McAuthentication;
    use quiche::multicast::MulticastClientStatus;
    use quiche::multicast::MulticastError;
    use quiche::multicast::MulticastRole;
    use quiche::Config;
    use quiche::Connection;
    use quiche::ConnectionId;

    use super::*;

    pub type McUnsigned = HashMap<u64, Vec<u8>>;

    pub fn get_mc_config(do_mc: bool, max_dgram_size: usize) -> Config {
        let mut config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();

        // *CAUTION*: this should not be set to `false` in production!!!
        config.verify_peer(false);

        config
            .set_application_protos(&[
                b"hq-interop",
                b"hq-29",
                b"hq-28",
                b"hq-27",
                b"http/0.9",
            ])
            .unwrap();

        // config.set_max_idle_timeout(5_000_000_000);
        config.set_max_recv_udp_payload_size(max_dgram_size);
        config.set_max_send_udp_payload_size(max_dgram_size);
        config.set_initial_max_data(10_000_000);
        config.set_initial_max_stream_data_bidi_local(1_000_000);
        config.set_initial_max_stream_data_bidi_remote(1_000_000);
        config.set_initial_max_stream_data_uni(1_000_000);
        config.set_initial_max_streams_bidi(1_000_000);
        config.set_initial_max_streams_uni(1_000_000);
        config.set_active_connection_id_limit(5);
        config.verify_peer(false);

        if do_mc {
            let mc_client_params = multicast::MulticastClientTp {
                ipv4_channels_allowed: true,
                ipv6_channels_allowed: true,
            };
            config.set_multipath(true);
            config.set_enable_client_multicast(Some(&mc_client_params));
            config.receive_fec(true);
            config.set_fec_scheduler_algorithm(
                quiche::FECSchedulerAlgorithm::RetransmissionFec,
            );
            config.set_fec_symbol_size(1280 - 64);
        }

        config
    }

    #[inline]
    pub fn client_connect(
        conn: &mut Connection, socket: &mut UdpSocket, buf: &mut [u8],
    ) -> std::result::Result<(), ()> {
        let (write, send_info) = conn.send(buf).expect("initial send failed");

        while let Err(e) = socket.send_to(&buf[..write], send_info.to) {
            if e.kind() == std::io::ErrorKind::WouldBlock {
                debug!("send() would block");
                continue;
            }

            return Err(());
        }

        debug!("written {}", write);

        Ok(())
    }

    #[inline]
    pub fn handle_empty_events(conn: &mut Connection) -> bool {
        conn.on_timeout();

        let now = std::time::Instant::now();
        if conn.on_mc_timeout(now) ==
            Err(quiche::Error::Multicast(
                multicast::MulticastError::McInvalidRole(MulticastRole::Client(
                    MulticastClientStatus::Leaving(true),
                )),
            ))
        {
            return true;
        }
        false
    }

    #[inline]
    pub fn read_socket_to_quiche(
        conn: &mut Connection, socket: &mut UdpSocket, buf: &mut [u8],
    ) -> std::io::Result<bool> {
        let (len, from) = match socket.recv_from(buf) {
            Ok(v) => v,

            Err(e) => {
                // There are no more UDP packets to read, so end the read
                // loop.
                if e.kind() == std::io::ErrorKind::WouldBlock {
                    return Ok(true);
                }

                return Err(e);
            },
        };

        debug!("got {} bytes", len);

        let recv_info = quiche::RecvInfo {
            to: socket.local_addr().unwrap(),
            from,
            from_mc: None,
        };

        debug!(
            "Received a packet on the unicast channel. Is it closed? {}",
            conn.is_closed()
        );

        // Process potentially coalesced packets.
        let _read = match conn.recv(&mut buf[..len], recv_info) {
            Ok(v) => v,

            Err(e) => {
                error!("recv failed: {:?}", e);
                return Ok(true);
            },
        };

        Ok(false)
    }

    #[inline]
    pub fn read_mc_data_socket_to_quiche(
        conn: &mut Connection, mc_socket: &mut UdpSocket, buf: &mut [u8],
        mc_na_packets: &mut McUnsigned, mc_addr: SocketAddr,
        peer_addr: SocketAddr,
    ) -> bool {
        let (len, _) = match mc_socket.recv_from(buf) {
            Ok(v) => v,
            Err(e) => {
                // There are no more UDP packets to read, so end the read
                // loop.
                if e.kind() == std::io::ErrorKind::WouldBlock {
                    return true;
                }

                panic!("recv() failed: {:?}", e);
            },
        };

        // If symmetric authentication is used, buffer the packets as long
        // as the corresponding authentication packet is not received.
        let can_read_pkt = if conn
            .get_multicast_attributes()
            .unwrap()
            .get_mc_auth_type() ==
            quiche::multicast::authentication::McAuthType::SymSign
        {
            // Get the packet number used as identifier. Woops for the
            // unwrap.
            let pn = match conn.mc_get_pn(&buf[..len]) {
                Ok(v) => v,
                Err(e) => {
                    error!("Error when reading the packet number: {:?}", e);
                    return false;
                },
            };

            debug!("Recv data packet with pn={}", pn);

            // Maybe the application already received the authentication
            // tag?
            match conn.mc_verify_sym(&buf[..len], pn) {
                Ok(()) => true,
                Err(quiche::Error::Multicast(MulticastError::McNoAuthPacket)) => {
                    // The authentication packet is not received yet.
                    // Store the packet until we receive it.
                    mc_na_packets.insert(pn, buf[..len].to_vec());
                    false
                },
                Err(e) => panic!(
                    "Err trying to authenticate with symmetric tag: {:?}",
                    e
                ),
            }
        } else {
            true
        };

        if can_read_pkt {
            debug!("Can read incomming packet");
            let recv_info = quiche::RecvInfo {
                to: mc_addr,
                from: peer_addr,
                from_mc: Some(McPathType::Data),
            };

            let _read = match conn.mc_recv(&mut buf[..len], recv_info) {
                Ok(v) => v,
                Err(e) => {
                    error!("Multicast failed: {:?}", e);
                    return false;
                },
            };
        } // Else: it is buffered until we receive the authentication
          // tag.
        false
    }

    #[inline]
    pub fn read_mc_auth_socket_to_quiche(
        conn: &mut Connection, mc_socket_auth: &mut UdpSocket, buf: &mut [u8],
        mc_na_packets: &mut McUnsigned, mc_addr: SocketAddr,
        mc_addr_auth: SocketAddr, peer_addr: SocketAddr,
    ) -> bool {
        let (len, _) = match mc_socket_auth.recv_from(buf) {
            Ok(v) => v,
            Err(e) => {
                // There are no more UDP packet to read, so end the read
                // loop.
                if e.kind() == std::io::ErrorKind::WouldBlock {
                    // debug!("recv() would block for auth mc");
                    return true;
                }

                panic!("recv() mc auth failed: {:?}", e);
            },
        };

        let recv_info = quiche::RecvInfo {
            to: mc_addr_auth,
            from: peer_addr,
            from_mc: Some(McPathType::Authentication),
        };

        debug!(
            "Recv a packet on the authentication path. Use {:?} recv_info",
            recv_info
        );

        let _read = match conn.mc_recv(&mut buf[..len], recv_info) {
            Ok(v) => v,
            Err(e) => {
                error!("Multicast auth failed: {:?}", e);
                return true;
            },
        };

        // Check if some previously non-authenticated packets can now be
        // processed.
        let recv_tags = conn.mc_get_client_auth_tags().unwrap();
        let pn_na_packets: Vec<_> = mc_na_packets.keys().map(|i| *i).collect();
        for pn in pn_na_packets {
            if recv_tags.contains(&pn) {
                // This packet can be authenticated and processed.
                let mut pkt_na = mc_na_packets.remove(&pn).unwrap();
                match conn.mc_verify_sym(&pkt_na, pn) {
                    Ok(()) => (),
                    Err(quiche::Error::Multicast(MulticastError::McInvalidSign)) => error!("Packet {} has invalid authentication!", pn),
                    Err(e) => error!("Unknown error when authenticating a previously received packet with symmetric tags: {:?}", e)
                }
                debug!("Can read packet 2 with pn={}", pn);
                let recv_info = quiche::RecvInfo {
                    to: mc_addr,
                    from: peer_addr,
                    from_mc: Some(McPathType::Data),
                };

                let read = match conn.mc_recv(&mut pkt_na[..], recv_info) {
                    Ok(v) => v,
                    Err(e) => {
                        error!("Multicast failed: {:?}", e);
                        continue;
                    },
                };
                debug!("Multicast QUIC read {} bytes", read);
                debug!(
                    "Readable streams: {:?}",
                    conn.readable().collect::<Vec<_>>()
                );
            }
        }

        return false;
    }

    #[inline]
    pub fn process_mc_events(
        conn: &mut Connection, mc_addr: SocketAddr, mc_addr_auth: SocketAddr,
        peer_addr: SocketAddr, uc_socket: &UdpSocket, do_auth_creation: bool,
    ) -> (Option<UdpSocket>, Option<UdpSocket>) {
        // Join the multicast channel and create the listening socket if not
        // already done.
        let mc_sock = if conn.mc_join_channel().is_ok() {
            let multicast = conn.get_multicast_attributes().unwrap();
            let mc_announce_data =
                multicast.get_mc_announce_data_path().unwrap().to_owned();
            // Did not join the multicast channel before.
            let mc_cid =
                ConnectionId::from_ref(&mc_announce_data.channel_id).into_owned();
            // MC-TODO: do we have to put another address here?
            info!(
                "Create second path. Client addr={:?}. Server addr={:?}",
                mc_addr, peer_addr
            );
            let mc_space_id = conn
                .create_mc_path(
                    &mc_cid,
                    mc_addr,
                    peer_addr,
                    mc_announce_data.is_ipv6,
                )
                .unwrap();
            conn.set_mc_space_id(mc_space_id, McPathType::Data).unwrap();

            // If soft-multicast is used by the source, the client will
            // receive multicast QUIC packets with its unicast
            // address as destination of the IP packet. Bind the socket to the
            // local address with the multicast destination port.
            let mc_group_sockaddr: net::SocketAddr = if mc_announce_data.is_ipv6 {
                let ip = uc_socket.local_addr().unwrap().ip();
                net::SocketAddr::new(ip, mc_announce_data.udp_port)
            } else {
                let group_ip =
                    net::Ipv4Addr::from(mc_announce_data.group_ip.to_owned());
                net::SocketAddr::V4(net::SocketAddrV4::new(
                    group_ip,
                    mc_announce_data.udp_port,
                ))
            };
            let local_ip = net::Ipv4Addr::new(127, 0, 0, 1);
            // MC-TODO: join the multicast group.
            let mc_socket = mio::net::UdpSocket::bind(mc_group_sockaddr).unwrap();
            debug!("Multicast client binds on address: {:?}", mc_group_sockaddr);
            if !mc_announce_data.is_ipv6 {
                mc_socket
                    .join_multicast_v4(
                        &net::Ipv4Addr::from(
                            mc_announce_data.group_ip.to_owned(),
                        ),
                        &local_ip,
                    )
                    .unwrap();
            }
            Some(mc_socket)
        } else {
            None
        };

        // Authentication path data not yet installed.
        let mc_sock_auth = if let (true, Some(mc_announce_auth)) = (
            do_auth_creation,
            conn.get_multicast_attributes()
                .unwrap()
                .get_mc_announce_data(1),
        ) {
            let mc_announce_auth = mc_announce_auth.to_owned();
            let auth_cid = ConnectionId::from_ref(&mc_announce_auth.channel_id);
            debug!("Create third path for authentication. Client addr={:?}. Server addr={:?}", mc_addr_auth, peer_addr);
            let mc_space_id = conn
                .create_mc_path(
                    &auth_cid,
                    mc_addr_auth,
                    peer_addr,
                    mc_announce_auth.is_ipv6,
                )
                .unwrap();
            conn.set_mc_space_id(mc_space_id, McPathType::Authentication)
                .unwrap();
            let mc_group_sockaddr = if mc_announce_auth.is_ipv6 {
                let ip = uc_socket.local_addr().unwrap().ip();
                net::SocketAddr::new(ip, mc_announce_auth.udp_port)
            } else {
                let group_ip =
                    net::Ipv4Addr::from(mc_announce_auth.group_ip.to_owned());
                net::SocketAddr::V4(net::SocketAddrV4::new(
                    group_ip,
                    mc_announce_auth.udp_port,
                ))
            };
            let local_ip = net::Ipv4Addr::new(127, 0, 0, 1);
            let mc_socket_auth =
                mio::net::UdpSocket::bind(mc_group_sockaddr).unwrap();
            debug!(
                "Multicast client binds on address for authentication: {:?}",
                mc_group_sockaddr
            );
            if !mc_announce_auth.is_ipv6 {
                mc_socket_auth
                    .join_multicast_v4(
                        &net::Ipv4Addr::from(
                            mc_announce_auth.group_ip.to_owned(),
                        ),
                        &local_ip,
                    )
                    .unwrap();
            }
            Some(mc_socket_auth)
        } else {
            None
        };

        (mc_sock, mc_sock_auth)
    }

    #[inline]
    pub fn client_send(
        conn: &mut Connection, out: &mut [u8], uc_socket: &mut UdpSocket,
        mc_socket: Option<&mut UdpSocket>,
        mc_socket_auth: Option<&mut UdpSocket>, mc_addr: SocketAddr,
        mc_addr_auth: SocketAddr,
    ) -> bool {
        let (write, send_info) = match conn.send(out) {
            Ok(v) => v,

            Err(quiche::Error::Done) => {
                // debug!("done writing");
                return true;
            },

            Err(e) => {
                error!("send failed: {:?}", e);

                conn.close(false, 0x1, b"fail").ok();
                return true;
            },
        };

        // Depending on the send_info, use the associated socket.
        // For simplicity use IPv4 only and match on the udp source port.
        let port_from = send_info.from.port();
        let socket_from = if port_from == uc_socket.local_addr().unwrap().port() {
            uc_socket
        } else if port_from == mc_addr.port() {
            mc_socket.unwrap()
        } else if port_from == mc_addr_auth.port() {
            mc_socket_auth.expect("Multicast auth socket is None")
        } else {
            panic!("Unknown port: {}", port_from);
        };

        if let Err(e) = socket_from.send_to(&out[..write], send_info.to) {
            if e.kind() == std::io::ErrorKind::WouldBlock {
                // debug!("send() would block");
                return true;
            }

            panic!("send() failed: {:?}", e);
        }

        false
    }
}
